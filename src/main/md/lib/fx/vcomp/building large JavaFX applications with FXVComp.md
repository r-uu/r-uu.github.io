# Building large JavaFX applications with ```FXVComp```

Large systems are typically built from smaller components which themselves are built from even smaller components and so on. This article describes an approach how to build JavaFX applications from components conviently.

## Abstract

```FXVComp``` provides support for building visual components with JavaFX that can be designed, run and tested on their own as well as be integrated into complex UI systems. In particular ```FXVComp``` leverages CDI that facilitates loose coupling and efficient collaboration of independent subsystems. Moreover ```FXVComp``` provides support for standardisation and automation of reusable JavaFX components.

## Visual components in ```FXVComp```

A visual component in ```FXVComp``` typically consists at least of the following parts:

* A ```.fxml``` file with the declarative description of the UI,
* a component class implementing ```de.ruu.lib.fx.comp.FXCView```,
* a component controller class implementing ```de.ruu.lib.fx.comp.FXCViewController``` that defines the behaviour of the component and
* a component service implementing ```de.ruu.lib.fx.comp.FXCViewService```.

Each part will be described in detail in one of the following sections.

> In fact there can be even more artifacts that are used by ```FXVComp``` components. These will also be described later. 

## ```FXVComp``` framework

Before describing the naming conventions and showing the ease of use of ```FXVComp``` here is an overview of the framework:

![```FXVComp``` framework overview](de.ruu.lib.fx.comp.png)

In the next section the ```FXVComp``` naming conventions will be described.

## The ```FXVComp``` naming conventions

The <code>FXComp</code> naming conventions support automation of recurring tasks when creating visual components. For a visual component named ```X``` the conventions expect:

* component class name: <code>X</code>
* component service interface name: <code>XService</code>
* component controller class name: <code>XController</code>
* application class name: <code>XApp</code>
* application runner class name: <code>XAppRunner</code>

These naming conventions can be overwritten in the classes described later.

Before going too much into details the following demonstrates the ease of use of ```FXVComp``` components.

## Using the ```FXVComp``` framework

When complying to the ```FXVComp``` naming conventions building a small but complete visual component is really easy. For creating a component named ```X``` the following simple steps have to be made.

> Moreover FXVComp comes with a generator tool, that creates skeletons for the necessary artifacts. This tool will be described later on.

### TODO add uml diagram with default and generated types!!!

### Create ```X.fxml``` file

```.fxml``` files contain declarative descriptions of the visual parts of the UI. [Gluon Scenebuilder](https://gluonhq.com/products/scene-builder/) is a visual designer tool to create ```.fxml``` files. The picture shows the visual appearance of the X component in scenebuilder.

![```X.fxml``` in scenebuilder](scenebuilder.png)

Here is the ```xml``` source code of ```X.fxml```generated by scenebuilder:

```xml
<?xml version="1.0" encoding="UTF-8"?>

<?import javafx.scene.control.Button?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.layout.AnchorPane?>

<AnchorPane maxHeight="-Infinity" maxWidth="-Infinity" minHeight="-Infinity" minWidth="-Infinity" prefHeight="165.0" prefWidth="228.0" xmlns="http://javafx.com/javafx/11.0.1" xmlns:fx="http://javafx.com/fxml/1">
   <children>
      <Label layoutX="33.0" layoutY="14.0" text="this is FXComp component X" />
      <Button fx:id="button" layoutX="80.0" layoutY="41.0" mnemonicParsing="false" text="click me" />
      <AnchorPane fx:id="anchorPane" layoutX="22.0" layoutY="79.0" prefHeight="73.0" prefWidth="174.0" />
   </children>
</AnchorPane>
```

### Implement ```FXCView```

If the default naming conventions suffice implementing a ```FXCView``` is as simple as:

```java
public class X extends DefaultFXCView { }
```

There is nothing more to be done but creating an (initially) empty class that ```extends DefaultFXCView```.

### Implement ```FXCViewController```

```X.fxml``` contains the declaration of four JavaFX components. Two of them (```button``` and ```anchorPane```) have a ```fx:id``` which makes them available in a controller class via JavaFX injection and the ```@FXML``` annotation.

Here is an implementation for ```XController```:

```java
public class XController extends DefaultFXCViewController
{
	@FXML private Button button;
	@FXML private AnchorPane anchorPane;

	@Override
	@FXML
	protected void initialize()
	{
		button.setOnAction(e -> System.out.println("button pressed in X component"));
	}
}
```

When clicking the button a message is printed to the console.

### Implement ```FXCViewService```

As long as there is no particular service a ```FXVComp``` component provides, writing a service interface is as simple as:

```java
public interface XService { }
```

xxx TODO XService has to extend FXCViewService!!! xxx

Obviously this is the case only for the most simple use cases.

### Implement ```FXCApp```


### Implement ```FXCAppRunner```

### ```FXCView```

In ```FXVComp``` a visual component implements ```FXCView```. Therefore it has to provide only two methods: ```getLocalRoot()``` and ```getService()```. In case the visual component does not expose any specific services the latter method can be implemented by just returning an empty implementation of ```FXCViewService```.

```getLocalRoot()``` provides a ```javafx.scene.Parent``` object that represents the root of the component's tree of nodes. The tree of nodes defines the visual appearance of the component.

### ```DefaultFXCView```

```DefaultFXCView``` is an abstract implementation of ```FXCView``` that leverages the ```FXVComp``` naming conventions to automate the bootstrapping of all the parts that contribute to the overall features of a ```FXVComp``` component. You can adjust the bootstrapping mechanisms by overriding protected methods.

In this implementation ```getLocalRoot()``` loads the component's tree of nodes from an <code>.fxml</code> file. It looks for the file by leveraging the <code>FXVComp</code> default naming conventions (see
{@link de.ruu.lib.fx.comp}) or the overridden return value from {@link
#getFXLMResourceName()}

You can run and test an implementation of ```DefaultFXCView``` conveniently with ```FXCApp``` and ```FXCAppRunner```.

### ```FXCApp```



### ```FXCAppRunner```

xxxxxxxxxxxxxxxx TODO xxxxxxxxxxxxxxxx

## Automation of recurring tasks

Regardless of using FXVComp or not ...

However, developers of non trivial JavaFX applications always have to deal with pretty much recurring tasks. ```FXVComp``` accomplishes this by a tool that automates the initial generation of skeletons for the artifacts in a very flexible manner. By default it will introduce a naming convention for the artifacts that standardises naming and helps to keep track of all the parts needed for ```FXVComp``` components. The conventions can be overwritten to meet specific needs.

In the following this article describes the mentioned framework and tooling in more detail and finally it will show how to build a small sample ```FXVComp``` component.

Code examples can be downloaded from [xxx](xxx).

A typical JavaFX application is composed from multiple artifacts. Following some naming conventions helps to keep track in this fast spreading jungle of files. Let's say we want to build an app called ```XApp```. Here is what non-trivial JavaFX apps are typically built from:

* ```XApp.java```

  A class that is derived from ```javafx.application.Application``` and that populates the ```javafx.stage.Stage``` with a ```javafx.scene.Scene```. JavaFX provides means to create a ```Scene``` instance from a declarative UI description file with the name suffix ```.fxml```: 

* ```XApp.fxml```
 


* ```XAppController.java```

  A JavaFX controller is a class that initialises the UI elements defined in a ```Scene``` and controls how the app reacts on UI events.

JavaFX comes with support for convenient injection of UI components into controller instances that define the behaviour of JavaFX applications. ```@FXML``` annotated fields in controller classes do the trick. 

However, the bigger applications grow the more urgent becomes the need to split it up into smaller, better maintainable pieces. The following shows how a JavaFX app can be built from smaller apps where each app can be run and tested on its own.

## Extending basic JavaFX building blocks

With JavaFX it is possible to create large UI applications from smaller JavaFX apps. This helps to make testing much easier and contributes to overall robustness.

This approach enhances the before mentioned basic building blocks of a JavaFX application:

* ```XAppService.java```

  An interface that defines the "external" component behaviour.

* ```XAppView.java```

  A view class that provides typical UI funcionality that may be useful for collaboration with other components.

* ```XAppRunner.java```

We'll have a closer look at each of these building blocks in the following.

### Extending ```javafx.application.Application``` -  ```CDIApplication```

```CDIApplication``` is an abstract sub class of ```javafx.application.Application```.


What is missing in vanilla JavaFX is built in support for CDI. And it can be challenging to properly bootstrap a CDI container without harmfully interferring JavaFX's startup procedure. The following chapter describes an approach that hides CDI bootstrapping and takes care of recurring tasks for JavaFX development.

that support injection via @FXML annotations and CDI.

I built a couple of JavaFX components and found myself doing the same things again and again. So I decided to automate these efforts. Here is a description for a use of a generator I have built for these tasks.

A typical 